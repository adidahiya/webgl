// Generated by CoffeeScript 1.3.1
(function() {
  var DISPLAY_TEXT, FLOAT_THRESHOLD, FOG_COLOR, FOG_DENSITY, GRAPH_THRESHOLD, LINE_COLOR, NUM_PARTICLES, PARTICLE_COLOR, PARTICLE_DEPTH, PARTICLE_SPEED, TEXT_COLOR, createFog, createGraph, createGraphLines, createParticleSystem, createText, generatePosition, generateSprite, generateVelocity, getRandomInt, init, lineMaterial, particleMaterial, renderLoop, setupScene, textMaterial;

  NUM_PARTICLES = 300;

  PARTICLE_DEPTH = 800;

  PARTICLE_SPEED = 4;

  PARTICLE_COLOR = 0x333333;

  LINE_COLOR = 0x666666;

  TEXT_COLOR = 0x003366;

  FOG_COLOR = 0xFFFFFF;

  FOG_DENSITY = 0.0012;

  GRAPH_THRESHOLD = 200;

  FLOAT_THRESHOLD = 50;

  DISPLAY_TEXT = "3D graph animation";

  generateSprite = function() {
    var canvas, context, gradient, h, w;
    w = 16;
    h = 16;
    canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
    context = canvas.getContext('2d');
    gradient = context.createRadialGradient(w, h, 0, w, h, w);
    gradient.addColorStop(0, 'rgba(50, 50, 50, 1)');
    gradient.addColorStop(0.4, 'rgba(50, 50, 50, 1)');
    gradient.addColorStop(1, 'rgba(255, 255, 255, 1)');
    context.fillStyle = gradient;
    context.fillRect(0, 0, w, h);
    return canvas;
  };

  getRandomInt = function(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  };

  particleMaterial = new THREE.ParticleBasicMaterial({
    color: PARTICLE_COLOR,
    size: 10,
    blending: THREE.AdditiveBlending
  });

  lineMaterial = function() {
    return new THREE.LineBasicMaterial({
      color: LINE_COLOR,
      linewidth: 1
    });
  };

  textMaterial = new THREE.MeshBasicMaterial({
    color: TEXT_COLOR
  });

  setupScene = function($container) {
    var ASPECT, FAR, HEIGHT, NEAR, VIEW_ANGLE, WIDTH, camera, renderer, scene;
    WIDTH = $container.width();
    HEIGHT = $container.height();
    VIEW_ANGLE = 45;
    ASPECT = WIDTH / HEIGHT;
    NEAR = 0.1;
    FAR = 10000;
    renderer = new THREE.WebGLRenderer({
      antialias: true
    });
    camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
    scene = new THREE.Scene();
    scene.add(camera);
    camera.position.z = 1000;
    camera.lookAt(new THREE.Vector3(0, 0, 0));
    renderer.setSize(WIDTH, HEIGHT);
    $container.append(renderer.domElement);
    return {
      renderer: renderer,
      camera: camera,
      instance: scene
    };
  };

  generatePosition = function() {
    var x, y, z;
    x = Math.random() * 3200 - 1600;
    y = Math.random() * 800 - 400;
    z = Math.random() * PARTICLE_DEPTH - PARTICLE_DEPTH / 2;
    return new THREE.Vector3(x, y, z);
  };

  generateVelocity = function() {
    var xVel, yVel, zVel;
    xVel = Math.random() * PARTICLE_SPEED - PARTICLE_SPEED / 2;
    yVel = Math.random() * PARTICLE_SPEED - PARTICLE_SPEED / 2;
    zVel = Math.random() * 0.4 - 0.2;
    return new THREE.Vector3(xVel, yVel, zVel);
  };

  createParticleSystem = function() {
    var geometry, i, particle, particles, _i;
    geometry = new THREE.Geometry();
    geometry.dynamic = true;
    for (i = _i = 1; 1 <= NUM_PARTICLES ? _i <= NUM_PARTICLES : _i >= NUM_PARTICLES; i = 1 <= NUM_PARTICLES ? ++_i : --_i) {
      particle = generatePosition();
      particle.initial = particle.clone();
      particle.velocity = generateVelocity();
      particle.accel = 0.95;
      particle.name = "" + (i - 1);
      geometry.vertices.push(particle);
    }
    particles = new THREE.ParticleSystem(geometry, particleMaterial);
    particles.sortParticles = true;
    return particles;
  };

  createGraph = function(particles) {
    var graph, index, p, subGraph, v1, v2, _i, _j, _len, _len1, _ref, _ref1;
    graph = {};
    _ref = particles.geometry.vertices;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v1 = _ref[_i];
      subGraph = [];
      _ref1 = particles.geometry.vertices;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        v2 = _ref1[_j];
        if (Math.abs(v1.distanceTo(v2)) < GRAPH_THRESHOLD && !v1.equals(v2)) {
          index = parseInt(v2.name);
          if (index != null) {
            subGraph.push(index);
          }
        }
      }
      if (subGraph.length) {
        p = parseInt(v1.name);
        graph[p] = subGraph;
      }
    }
    return graph;
  };

  createGraphLines = function(particles, graph) {
    var connected, graphLines, i, lines, particle, root, rootIndex, subGraph, _i, _len;
    graphLines = [];
    for (rootIndex in graph) {
      connected = graph[rootIndex];
      subGraph = new THREE.Geometry();
      root = particles.geometry.vertices[parseInt(rootIndex)];
      for (_i = 0, _len = connected.length; _i < _len; _i++) {
        i = connected[_i];
        particle = particles.geometry.vertices[i];
        if (particle != null) {
          subGraph.vertices.push(particle);
        }
        subGraph.vertices.push(root);
      }
      lines = new THREE.Line(subGraph, lineMaterial());
      lines.name = "graphLines";
      graphLines.push(lines);
    }
    return graphLines;
  };

  createText = function() {
    var centerOffset, textGeometry, textMesh;
    textGeometry = new THREE.TextGeometry(DISPLAY_TEXT, {
      size: 60,
      height: 5,
      curveSegments: 4,
      font: "helvetiker",
      weight: "normal",
      style: "normal"
    });
    textGeometry.computeBoundingBox();
    centerOffset = -0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);
    textMesh = new THREE.Mesh(textGeometry, textMaterial);
    textMesh.position.set(centerOffset, -30, 0);
    return textMesh;
  };

  createFog = function() {
    var fog;
    fog = new THREE.FogExp2(FOG_COLOR, FOG_DENSITY);
    return fog;
  };

  renderLoop = function(scene) {
    var frame, update;
    frame = 0;
    update = function() {
      var line, newGraphLines, oldGraphLines, particle, _i, _j, _len, _len1, _ref;
      _ref = scene.particles.geometry.vertices;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        particle = _ref[_i];
        particle.addSelf(particle.velocity);
        if (Math.abs(particle.y - particle.initial.y) > FLOAT_THRESHOLD) {
          particle.velocity.setY(-1 * particle.velocity.y);
        }
        if (Math.abs(particle.x - particle.initial.x) > FLOAT_THRESHOLD) {
          particle.velocity.setX(-1 * particle.velocity.x);
        }
        if (Math.abs(particle.z - particle.initial.z) > FLOAT_THRESHOLD) {
          particle.velocity.setZ(-1 * particle.velocity.z);
        }
      }
      scene.particles.geometry.verticesNeedUpdate = true;
      newGraphLines = createGraphLines(scene.particles, scene.graph);
      oldGraphLines = scene.instance.getChildByName("graphLines");
      while (oldGraphLines) {
        scene.instance.remove(oldGraphLines);
        oldGraphLines = scene.instance.getChildByName("graphLines");
      }
      for (_j = 0, _len1 = newGraphLines.length; _j < _len1; _j++) {
        line = newGraphLines[_j];
        scene.instance.add(line);
      }
      scene.renderer.render(scene.instance, scene.camera);
      return requestAnimationFrame(update);
    };
    return requestAnimationFrame(update);
  };

  init = function() {
    var graph, graphLines, particles, scene, sceneText, subGraph, _i, _len;
    scene = setupScene($('#sketch'));
    particles = createParticleSystem();
    graph = createGraph(particles);
    graphLines = createGraphLines(particles, graph);
    sceneText = createText();
    scene.instance.add(particles);
    for (_i = 0, _len = graphLines.length; _i < _len; _i++) {
      subGraph = graphLines[_i];
      scene.instance.add(subGraph);
    }
    scene.instance.fog = createFog();
    scene.instance.add(sceneText);
    scene.graph = graph;
    scene.particles = particles;
    return renderLoop(scene);
  };

  init();

}).call(this);
